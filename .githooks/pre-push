#!/bin/bash
# Pre-push hook for Gartan Scraper Bot
# Runs comprehensive tests and validations before pushing.
# Adds explicit timeouts & robust cleanup to avoid hanging pushes.

set -euo pipefail

DOCKER_BUILD_TIMEOUT=${DOCKER_BUILD_TIMEOUT:-300}   # seconds (5m default)
API_START_TIMEOUT=${API_START_TIMEOUT:-10}

echo "üöÄ Running pre-push checks (timeouts: docker=${DOCKER_BUILD_TIMEOUT}s api=${API_START_TIMEOUT}s)..."

# Function: returns 0 if branch is behind its remote tracking ref, 1 otherwise
is_branch_behind() {
    local branch remote_ref
    branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "") || return 1
    [[ -z "$branch" ]] && return 1
    # Only handle main explicitly for now
    if [[ "$branch" != "main" ]]; then
        return 1
    fi
    git fetch -q origin main || return 1
    # Count commits: origin/main..HEAD are commits ahead; HEAD..origin/main are behind
    read -r ahead behind < <(git rev-list --left-right --count origin/main...HEAD 2>/dev/null | awk '{print $2,$1}')
    # above awk prints ahead behind (swap because --left-right puts left=origin/main right=HEAD)
    # If behind > 0 and ahead == 0 (purely behind) OR behind > 0 with mixed divergence treat as behind
    if [[ ${behind:-0} -gt 0 ]]; then
        return 0
    fi
    return 1
}

# Early divergence fail-fast
if is_branch_behind; then
    echo "‚ö†Ô∏è  Local main is behind origin/main. Please rebase (git pull --rebase origin main) then push again. Aborting before long-running checks."
    exit 1
fi

# Ensure cleanup always happens
cleanup() {
    if [[ -n "${server_pid:-}" ]]; then
        kill "$server_pid" 2>/dev/null || true
    fi
}
trap cleanup EXIT INT TERM

# Ensure logs directory exists early for redirections
mkdir -p logs

# Run all tests including integration tests (with parallel execution if available)
echo "üß™ Running comprehensive test suite..."
if python -c "import pytest_xdist" 2>/dev/null; then
    echo "Using parallel test execution..."
    python -m pytest tests/ -n auto --quiet --tb=short || {
        echo "‚ùå Comprehensive tests failed"
        exit 1
    }
else
    echo "Running tests sequentially (install pytest-xdist for parallel execution)..."
    python -m pytest tests/ --quiet --tb=short || {
        echo "‚ùå Comprehensive tests failed"
        exit 1
    }
fi

# Check that API server can start
echo "üåê Testing API server startup (timeout ${API_START_TIMEOUT}s)..."
python api_server.py > logs/prepush_api_start.log 2>&1 &
server_pid=$!

# Poll /health until success or timeout
start_ts=$(date +%s)
health_ok=0
elapsed=0
while true; do
    if curl -fsS http://localhost:5000/health > /dev/null 2>&1; then
    health_ok=1
    now=$(date +%s)
    elapsed=$(( now - start_ts ))
    break
    fi
    now=$(date +%s)
    elapsed=$(( now - start_ts ))
    if (( elapsed >= API_START_TIMEOUT )); then
        break
    fi
    sleep 1
done

if [[ $health_ok -eq 1 ]]; then
    echo "‚úÖ API server starts successfully (ready in ${elapsed}s)"
else
    echo "‚ùå API server failed to become ready within ${API_START_TIMEOUT}s"
    echo "---- api_server log (last 60 lines) ----"
    tail -n 60 logs/prepush_api_start.log 2>/dev/null || echo "(no log captured)"
    kill $server_pid 2>/dev/null || true
    exit 1
fi

# Stop API server (trap will also catch if earlier fail)
kill $server_pid 2>/dev/null || true

# Check Docker build (if Docker is available)
if command -v docker &> /dev/null; then
    DO_DOCKER_BUILD=1
    # Allow explicit skip via env var
    if [[ "${PRE_PUSH_SKIP_DOCKER:-0}" == "1" ]]; then
        echo "‚ÑπÔ∏è  PRE_PUSH_SKIP_DOCKER=1 set; skipping docker build test"
        DO_DOCKER_BUILD=0
    else
        # Quick daemon readiness probe (avoid long 300s wait if daemon not running)
        if command -v timeout >/dev/null 2>&1; then
            timeout 8s docker info > /dev/null 2>&1 || docker_info_rc=$?
        else
            docker info > /dev/null 2>&1 || docker_info_rc=$?
        fi
        if [[ ${docker_info_rc:-0} -ne 0 ]]; then
            if [[ "${PRE_PUSH_REQUIRE_DOCKER:-0}" == "1" ]]; then
                echo "‚ùå Docker daemon not reachable (docker info failed) and PRE_PUSH_REQUIRE_DOCKER=1 enforced"
                exit 1
            else
                echo "‚ö†Ô∏è  Docker daemon not reachable; skipping docker build test (set PRE_PUSH_REQUIRE_DOCKER=1 to enforce)"
                DO_DOCKER_BUILD=0
            fi
        fi
    fi
    if [[ $DO_DOCKER_BUILD -eq 1 ]]; then
        # Re-check divergence just before an expensive docker build (remote may have advanced during tests)
        if is_branch_behind; then
            echo "‚ö†Ô∏è  Local main became behind origin/main during tests. Rebase (git pull --rebase origin main) then retry push. Skipping docker build."
            exit 1
        fi
        echo "üê≥ Testing Docker build (timeout ${DOCKER_BUILD_TIMEOUT}s)..."
        build_log="logs/prepush_docker_build.log"
        mkdir -p logs
        build_rc=0
        if command -v timeout >/dev/null 2>&1; then
            timeout ${DOCKER_BUILD_TIMEOUT}s docker build --pull --progress=plain -t gartan-scraper-test . >"$build_log" 2>&1 || build_rc=$?
            if [[ $build_rc -eq 124 ]]; then
                echo "‚ùå Docker build timed out after ${DOCKER_BUILD_TIMEOUT}s. Last 60 lines:" >&2
                tail -n 60 "$build_log" || true
                exit 1
            fi
        else
            build_start=$(date +%s)
            docker build --pull --progress=plain -t gartan-scraper-test . >"$build_log" 2>&1 || build_rc=$?
            build_end=$(date +%s)
            build_elapsed=$(( build_end - build_start ))
            if (( build_elapsed > DOCKER_BUILD_TIMEOUT )); then
                echo "‚ö†Ô∏è  Docker build exceeded suggested timeout (${build_elapsed}s > ${DOCKER_BUILD_TIMEOUT}s)" >&2
            fi
        fi
        if [[ $build_rc -ne 0 ]]; then
            echo "‚ùå Docker build failed (exit=$build_rc). Last 60 lines:" >&2
            tail -n 60 "$build_log" || true
            exit 1
        fi
        echo "‚úÖ Docker build successful"
        docker rmi gartan-scraper-test > /dev/null 2>&1 || true
    fi
else
    echo "‚ÑπÔ∏è  Docker not found; skipping image build test"
fi

# Check for large files
echo "üìè Checking for large files..."
large_files=$(git ls-files | xargs ls -l | awk '$5 > 1048576 {print $9, $5}' || true)
if [ -n "$large_files" ]; then
    echo "‚ö†Ô∏è  Warning: Large files detected (>1MB):"
    echo "$large_files"
    echo "Consider using Git LFS for large files"
fi

# Check for secrets in code
echo "üîí Checking for potential secrets..."
secret_patterns=("password" "secret" "token" "api_key")
for pattern in "${secret_patterns[@]}"; do
    matches=$(git diff origin/main --name-only | xargs grep -il "$pattern" 2>/dev/null | grep -v ".env.example" || true)
    if [ -n "$matches" ]; then
        echo "‚ö†Ô∏è  Warning: Potential secrets found in files containing '$pattern':"
        echo "$matches"
        echo "Please review these files to ensure no secrets are committed"
    fi
done

echo "‚úÖ All pre-push checks passed!"
